\documentclass{article}

\usepackage{pgfkeys}
\usepackage{tikz}

\usetikzlibrary{graphdrawing}

\usegdlibrary{force}

% NAMING CONVENTIONS
% graph element: [external node, internal node, selector edge, selector label, hyperedge node, hyperedge tentacle, hyperedge tentacle label]
%
% graph element involvement: [rule1, rule2, both, new]
%                Note: Specifies in which rule application a graph element is involved; only applies to critical pair reports
%
% critical pair step: [joint graph, applied rule 1, applied rule 2, canonical 1, canonical 2]
%                Note: only applies to critical pair reports
% grammar part: [left side, right side]
%                Note: only applies to grammar reports
%
% report element id: [report element 1, report element 2, ...]
%                        Note: A report element can be a critical pair, a grammar rule or a heap configuration report
%
% identifier: node identifier, hyperedge identifier, tentacle identifier, selector identifier
% node identifier: <graph id of the node>
% hyperedge identifier: <graph id of the hyperedge>
% tentacle identifier: <graph id of the hyperedge> <tentacle index>
% selector identifier: <graph id of the source node> <label of selector>
%
% concrete id: [1/rule1/node/1, 1/left side/hyperedge/2, 1/selector edge/1 right, 1/selector label/1 right, 1/hyperedge tentacle/1 2, 1/hyperedge tentacle label/1 2, ...]
%                     Note: Identifies exactly one graph element;
%             Format: "[report element id]/[critical pair step]/[graph element]/[identifier]"   for critical pair report element
%             Format: "[report element id]/[grammar part]/[graph element]/[identifier]"   for grammar report element
%             Format: "[report element id]/[graph element]/[identifier]"   for heap configuration report element
%            Important: [graph element] references nodes just by the word "node" and NOT "external node" or "internal node"

%
% Show "graph id": TODO
% Show "report element id": TODO


% Tikz parameters to investigate
%
% weight (give nodes & edges an "importance" -> meaning depends on drawing algorithm)
% length (set length of edge)
% radius (of circular objects)

% Global options: node distance=1cm

% Section 32.1 Controlling and Configuring Force-Based Algorithms
% iterations=500  (global)
% spring constant=0.01 (per edge or global?)
% electric charge=1  (per node or global -> attraction / repulsion between nodes)
% electric force order=1 (global -> reduce long range forces)
% approximate remote forces=true (global -> dont calculate every interaction)
% coarsen=true  (global -> Joins nodes to a coarse graph initially and then refines) -> Other options to configure this further

% Force based Layout algorithms
% spring layout, spring Hu 2006 layout, spring electrical layout, spring electrical layout', spring electrical Hu 2006 layout, spring electrical Walshaw 2000 layout




% TODO: Define macros

% Global style settings
\tikzset {  % TODO: Add style options that distinguish nodes/edges that are from rule 1 / rule 2 or both
    external node/.style={draw,circle,double},
    internal node/.style={draw,circle},
    selector edge/.style={red,->,thick},
    selector label/.style={auto,sloped},
    hyperedge node/.style={draw,green,rectangle},
    hyperedge tentacle/.style={blue,thick},
    hyperedge tentacle label/.style={auto,sloped},
    global heap drawing settings/.style={spring layout,node distance=1.5cm},
    grammar derivation arrow/.style={}
}

\newcommand{\SetBaselineCenter}[1]{\raisebox{-0.5\height}{#1}}
\newcommand{\SetBaselineTop}[1]{\raisebox{-1\height}{#1}}

\newcommand{\AttestorCriticalPairReport}{
    \section{Critical Pair}  % TODO: Enumerate the critical pairs
    Strongly joinable  % TODO: Replace with joinability result

    \begin{tabular}{cc}
        \multicolumn{2}{c}{\tikz{\AttestorDrawHeapConfiguration{/joint graph}}}\\
        \SetBaselineTop{\tikz{\AttestorDrawHeapConfiguration{/applied rule 1}}} & \SetBaselineTop{\tikz{\AttestorDrawHeapConfiguration{/applied rule 2}}}\\
        \SetBaselineCenter{\tikz{\AttestorDrawHeapConfiguration{/canonical 1}}} & \SetBaselineCenter{\tikz{\AttestorDrawHeapConfiguration{/canonical 2}}}\\
    \end{tabular}

    % TODO: Add the other abstracted graphs
    % Table with debug information
    %\begin{tabular}{ r | l l | l l }
    %    Node & Type R1 & Type R2 & Red. tent. R1 & Red. tent. R2 \\
    %    \hline
    %    1 & NULL  & NULL  & N/A  & False \\
    %    2 & type1 & type1 & True & False \\
    %    3 & NULL  & type1 & N/A  & False \\
    %    4 & type2 & NULL  & N/A  & True  \\
    %    5 & NULL  & NULL  & N/A  & False \\
    %\end{tabular}
}

\newcommand{\AttestorGrammarReport}{
    \section{Grammar Rule}

    \SetBaselineCenter{\tikz{\AttestorDrawHeapConfiguration{/left hand side}}}
    \hspace{2cm}
    \SetBaselineCenter{\tikz{\AttestorDrawHeapConfiguration{/right hand side}}}
}

\newcommand{\AttestorHeapConfigurationReport}{
    \section{Heap Configuration}

    \tikz{\AttestorDrawHeapConfiguration{/}}
}

% HELPER MACROS

% A for loop equivalen to the Java code: "for (int #1=0; #1<#2; #1++) {#3}"
\newcommand{\ForLoop}[3]{
    \edef\End{#2}
    \foreach #1 in {0,...,\End} {
        \edef\Current{#1}
        \ifx \Current \End
        \else
            #3
        \fi
    }
}

% #1 is the pgfkeys prefix. The macro must be called from inside a tikzpicture environment
\newcommand{\AttestorDrawHeapConfiguration}[1] {
    \pgfkeys{#1/nodes/.get=\nodelist}
    \pgfkeys{#1/nonterminals/.get=\nonterminalList}
    % 1. Rendering pass: Only draw nodes correctly for the node placement algorithm (otherwise there is an issue with the edges)
    \begin{scope}[global heap drawing settings]
        % 1. draw nodes
        \foreach \n in \nodelist {
            \node [internal node] (node\n) {\n};  % TODO: Change internal / external
        }
        % 2. draw selector edges
        \foreach \source in \nodelist {
            \pgfkeys{#1/nodes/\source/selector targets/.get=\targets}
            \foreach \target in \targets {
                \draw (node\source) edge [draw=none] (node\target);
            }
        }
        % 3. draw nonterminals
        \foreach \nonterminal in \nonterminalList {
            \pgfkeys{#1/nonterminals/\nonterminal/label/.get=\nonterminalLabel}
            \node [hyperedge node] (nonterminal\nonterminal) {\nonterminalLabel};
            \pgfkeys{#1/nonterminals/\nonterminal/tentacle targets/.get=\targets}
            \foreach \target in \targets {
                \draw (nonterminal\nonterminal) edge [draw=none] (node\target);
            }
        }
    \end{scope}
    % 2. Rendering pass: This time we draw the selectors with edge labels

    % Draw selector edges
    \foreach \source in \nodelist {
        \pgfkeys{#1/nodes/\source/selector targets/.get=\targets}
        \foreach \target in \targets {
            \pgfkeys{#1/nodes/\source/selector/\target/.get=\labels}
            \foreach \selectorLabel in \labels {
                \draw (node\source) edge [selector edge] node [selector label] {\selectorLabel} (node\target);
            }
        }
    }
    % Draw nonterminal tentacles
    \foreach \nonterminal in \nonterminalList {
        \pgfkeys{#1/nonterminals/\nonterminal/tentacle targets/.get=\targets}
        \foreach \target in \targets {
            \pgfkeys{#1/nonterminals/\nonterminal/tentacles/\target/.get=\labels}
            \foreach \tentacle in \labels {
                \draw (nonterminal\nonterminal) edge [hyperedge tentacle] node [hyperedge tentacle label] {\tentacle} (node\target);
            }
        }
    }

}
