package de.rwth.i2.attestor.automata;

import de.rwth.i2.attestor.grammar.Grammar;
import de.rwth.i2.attestor.graph.Nonterminal;
import de.rwth.i2.attestor.graph.heap.HeapConfiguration;
import gnu.trove.iterator.TIntIterator;

import java.util.*;

/**
 * The purpose of a heap automaton is twofold: First, it is the formal device to label heap configurations that
 * have, for example, been generated by the state space generation. This enables subsequent model checking.
 * Second, a heap automaton allows to refine a graph grammar to take its encoded properties into account.
 *
 * This class supports both operations: A move of a heap automaton on a single heap configuration and refinement of
 * grammars.
 *
 * @author Christoph
 */
public class HeapAutomaton {

    private TransitionRelation transitions;

    public HeapAutomaton(TransitionRelation transitions) {
        this.transitions = transitions;
    }

    /**
     * Run the automaton on a heap configuration.
     * @param heapConfiguration A heap configuration whose nonterminal edges are already annotated with states of the
     *                          automaton.
     * @return The state reached after one transition step.
     */
    public AutomatonState move(HeapConfiguration heapConfiguration) {

        return transitions.move(
                extractStateAssignment(heapConfiguration),
                heapConfiguration
        );
    }

    /**
     * Determines a list of all automaton states assigned to nonterminal edges in the given heap configuration.
     * The order of this list coincides with the order of nonterminal edges.
     * @param heapConfiguration A heap configuration whose automaton states should be determined.
     * @return A list of the automaton states assigned to each nonterminal edge.
     */
    private List<AutomatonState> extractStateAssignment(HeapConfiguration heapConfiguration) {

        List<AutomatonState> stateAssignments = new ArrayList<>(heapConfiguration.countNonterminalEdges());
        TIntIterator iter = heapConfiguration.nonterminalEdges().iterator();
        while(iter.hasNext()) {
            int edge = iter.next();
            Nonterminal nt = heapConfiguration.labelOf(edge);
            stateAssignments.add( extractState(nt) );
        }
        return stateAssignments;
    }

    /**
     * Determines the automaton state assigned to a given nonterminal.
     * If no such state exists an IllegalStateException is thrown.
     * @param nt The nonterminal.
     * @return The automaton state corresponding to the nonterminal.
     */
    private AutomatonState extractState(Nonterminal nt) {
        if(nt instanceof RefinedNonterminal) {
            AutomatonState res = ((RefinedNonterminal) nt).getState();
            if(res != null) {
                return res;
            }
        }

        throw new IllegalStateException("Provided nonterminal is not annotated with an automaton state.");
    }

    /**
     * Refines a grammar according to the heap automaton by annotation of nonterminal edges.
     * @param grammar The original grammar.
     * @return The refined grammar.
     */
    public Grammar refine(Grammar grammar) {

        GrammarRefinementHelper helper = new GrammarRefinementHelper(grammar, transitions);
        return helper.getRefinedGrammar();
    }
}
