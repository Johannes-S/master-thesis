package de.rwth.i2.attestor.automata;

import de.rwth.i2.attestor.grammar.Grammar;
import de.rwth.i2.attestor.graph.Nonterminal;
import de.rwth.i2.attestor.graph.heap.HeapConfiguration;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.array.TIntArrayList;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * The purpose of a heap automaton is twofold: First, it is the formal device to label heap configurations that
 * have, for example, been generated by the state space generation. This enables subsequent model checking.
 * Second, a heap automaton allows to refine a graph grammar to take its encoded properties into account.
 *
 * This class supports both operations: A move of a heap automaton on a single heap configuration and refinement of
 * grammars.
 *
 * @author Christoph
 */
public abstract class HeapAutomaton {

    protected abstract AutomatonState move(List<AutomatonState> ntAssignment, HeapConfiguration heapConfiguration);

    public List<HeapConfiguration> refineHeapConfiguration(HeapConfiguration heapConfiguration, Grammar grammar,
                                                      Set<String> desiredAPs) {

        Set<Nonterminal> nonterminals = grammar.getAllLeftHandSides();

        List<List<Nonterminal>> ntAssignments = new ArrayList<>();
        TIntArrayList ntEdges = heapConfiguration.nonterminalEdges();
        for(int i=0; i < ntEdges.size(); i++) {

            int edge = ntEdges.get(i);
            Nonterminal label = heapConfiguration.labelOf(edge);
            ntAssignments.add(findMatchingNonterminals(label, nonterminals));
        }

        AssignmentIterator<Nonterminal> ntAssignmentIterator = new AssignmentIterator<>(ntAssignments);
        List<HeapConfiguration> result = new ArrayList<>();
        while(ntAssignmentIterator.hasNext()) {
            List<Nonterminal> assignment = ntAssignmentIterator.next();
            List<AutomatonState> states = new ArrayList<>(assignment.size());
            assignment.forEach(n -> states.add(extractState(n)));
            AutomatonState assignedState = move(states, heapConfiguration);
            if(assignedState.getAtomicPropositions().containsAll(desiredAPs)) {
                HeapConfiguration copy = heapConfiguration.clone();
                TIntArrayList edges = copy.nonterminalEdges();
                for (int i = 0; i < edges.size(); i++) {
                    int edge = edges.get(i);
                    copy.builder().replaceNonterminal(edge, assignment.get(i));
                }
                copy.builder().build();
                result.add(copy);
            }
        }

        assert(!result.isEmpty());
        return result;
    }

    private List<Nonterminal> findMatchingNonterminals(Nonterminal nt, Set<Nonterminal> availableNonterminals) {

        List<Nonterminal> result = new ArrayList<>(availableNonterminals.size());
        for(Nonterminal a : availableNonterminals) {

            if(a.getLabel().equals(nt.getLabel())) {
                result.add(a);
            }
        }
        return result;
    }

    /**
     * Run the automaton on a heap configuration.
     * @param heapConfiguration A heap configuration whose nonterminal edges are already annotated with states of the
     *                          automaton.
     * @return The state reached after one transition step.
     */
    public AutomatonState move(HeapConfiguration heapConfiguration) {

        return move(
                extractStateAssignment(heapConfiguration),
                heapConfiguration
        );
    }

    /**
     * Refines a grammar according to the heap automaton by annotation of nonterminal edges.
     * @param grammar The original grammar.
     * @return The refined grammar.
     */
    public Grammar refine(Grammar grammar) {

        GrammarRefinementHelper helper = new GrammarRefinementHelper(grammar, this);
        return helper.getRefinedGrammar();
    }

    /**
     * Determines a list of all automaton states assigned to nonterminal edges in the given heap configuration.
     * The order of this list coincides with the order of nonterminal edges.
     * @param heapConfiguration A heap configuration whose automaton states should be determined.
     * @return A list of the automaton states assigned to each nonterminal edge.
     */
    private static List<AutomatonState> extractStateAssignment(HeapConfiguration heapConfiguration) {

        List<AutomatonState> stateAssignments = new ArrayList<>(heapConfiguration.countNonterminalEdges());
        TIntIterator iter = heapConfiguration.nonterminalEdges().iterator();
        while(iter.hasNext()) {
            int edge = iter.next();
            Nonterminal nt = heapConfiguration.labelOf(edge);
            stateAssignments.add( extractState(nt) );
        }
        return stateAssignments;
    }

    /**
     * Determines the automaton state assigned to a given nonterminal.
     * If no such state exists a dummy state is created.
     * @param nt The nonterminal.
     * @return The automaton state corresponding to the nonterminal.
     */
    private static AutomatonState extractState(Nonterminal nt) {
        if(nt instanceof RefinedNonterminal) {
            AutomatonState res = ((RefinedNonterminal) nt).getState();
            if(res != null) {
                return res;
            }
        }

        return new NullAutomatonState();
    }


}
